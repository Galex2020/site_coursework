<!DOCTYPE HTML>

<html>
	<head>
		<title>OOP study</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload no-sidebar">
		<div id="page-wrapper">

			<!-- Header -->
				<div id="header-wrapper">
					<header id="header" class="container">

						<!-- Logo -->
							<div id="logo">
								<h1><a href="index.html">ООП</a></h1>
								<span>МЕТОДИЧЕСКИЕ МАТЕРИАЛЫ</span>
							</div>

						<!-- Nav -->
							<nav id="nav">
								<ul>
									<li><a href="index.html">Главная</a></li>
									<li><a href="left-sidebar-1.1.html">Введение</a></li>
									<li><a href="left-sidebar-2.1.html">ООП в C#</a></li>
									<li class="current"><a href="no-sidebar.html">Принципы</a></li>
								</ul>
							</nav>

					</header>
				</div>

			<!-- Main -->
				<div id="main-wrapper">
					<div class="container">
						<div id="content">

							<!-- Content -->
								<article>

									<h2>10 принципов ООП, о которых стоит знать каждому программисту</h2>

									<p style='font-size:1.1em'>Многим опытным разработчикам, вероятно, знакома методология объектно-ориентированного программирования (ООП).
									Кроме известных её принципов (абстракция, инкапсуляция, полиморфизм, наследование и т. д.) существуют и другие —
									менее известные, но не менее важные и полезные для реализации.
									Некоторые из них собраны в специальный блок и известны по акрониму SOLID.
									Эта статья расскажет об этих и других существующих принципах объектно-ориентированной разработки и о том, какие преимущества они предлагают.</p>

									<h3><br>Принцип единственной ответственности (SRP)</h3>

									<p style='font-size:1.1em'>Соответствует букве S акронима SOLID.
									Согласно этому принципу, не должно быть более одной причины для изменения класса, или класс должен всегда обрабатывать одну функциональность.</p>
									<p style='font-size:1.1em'>Основное преимущество состоит в том, что такой подход уменьшает связь между отдельным компонентом программного обеспечения и кодом.
									Если вы добавляете более одной функциональности в один класс, это вводит связь между двумя функциями, и даже если вы меняете только одну из них,
									есть шанс сломать другую, связанную с ней. Что в свою очередь требует больше раундов тестирования для избежания каких-либо неожиданностей в продакшене.</p>

									<h3><br>Принцип открытости/закрытости (OCP)</h3>

									<p style='font-size:1.1em'>Соответствует букве O акронима SOLID.
									Принцип можно выразить так: «Классы, методы или функции должны быть открыты для расширения (добавления новой функциональности) и закрыты для модификации».
									Такой подход запрещает кому-либо изменять уже опробованный и протестированный код, а значит, он не ломается.
									В этом и состоит основное преимущество такого подхода.</p>

									<h3><br>Принцип подстановки Барбары Лисков (LSP)</h3>

									<p style='font-size:1.1em'>Соответствует букве L акронима SOLID.
									Согласно этому принципу подтипы должны быть заменяемыми для супертипа.
									Другими словами, методы или функции, работающие с суперклассом, должны иметь возможность без проблем работать также и с его подклассами.</p>
									<p style='font-size:1.1em'>LSP тесно связан с принципом единственной ответственности и принципом разделения интерфейса.
									Если класс реализует больше функциональности, чем подкласс, то последний может не поддерживать некоторые функции и тем самым нарушает данный принцип.</p>

									<h3><br>Принцип разделения интерфейса (ISP)</h3>

									<p style='font-size:1.1em'>Соответствует букве I акронима SOLID.
									Этот принцип подразумевает, что интерфейс, который не используется, не должен быть реализован.
									В основном это происходит, когда один интерфейс содержит несколько функциональностей, и клиенту нужна только одна из них, а другие — нет.</p>
									<p style='font-size:1.1em'>Написание интерфейса — сложная задача. Когда он готов, вы не сможете изменить его, не нарушив всю реализацию.</p>
									<p style='font-size:1.1em'>Ещё одно преимущество этого принципа в C# заключается в том, что интерфейс имеет недостаток.
									Необходимо сначала реализовать все методы, прежде чем какой-либо класс сможет их использовать.
									Поэтому наличие единственной функциональности означает меньшее количество методов для реализации.</p>

									<h3><br>Принцип инверсии зависимостей (DIP)</h3>

									<p style='font-size:1.1em'>Соответствует букве D акронима SOLID.
									Прелесть этого принципа проектирования в том, что любой класс легко тестируется с помощью фиктивного объекта и проще в обслуживании,
									потому что код создания объекта централизован, а клиентский код не перегружен им.</p>

									<h3><br>DRY (Don’t Repeat Yourself)</h3>

									<p style='font-size:1.1em'>Переводится как «не повторяйся» и буквально означает, что нужно уходить от дублирующего кода и по возможности использовать абстракцию для общих вещей.</p>
									<p style='font-size:1.1em'>Если есть одинаковый блок кода в более чем двух местах, вынесите его в отдельный метод.
									Если вы используете жёстко запрограммированное значение более одного раза, сделайте его общедоступной константой.
									Преимущество этого принципа заключается в упрощении поддержки вашего кода.</p>
									<p style='font-size:1.1em'>Но важно не злоупотреблять этим принципом.
									Например, один и тот же код не подойдёт для проверки OrderId и SSN.
									Их форматы могут не совпадать, и на выходе функция выдаст некорректный результат.
									В качестве решения можно предусмотреть в методе проверку форматов для подобных наборов чисел.</p>

									<h3><br>Инкапсуляция изменяющегося кода</h3>

									<p style='font-size:1.1em'>Сервисы стремительно развиваются.
									Продакшн подразумевает постоянные изменения кода и его поддержку.
									Отсюда следует второй принцип ООП — инкапсуляция кода, который с большой вероятностью будет изменён в будущем.</p>
									<p style='font-size:1.1em'>Преимущество этого принципа ООП заключается в том, что инкапсулированный код легко тестировать и поддерживать.</p>
									<p style='font-size:1.1em'>Воспользуйтесь алгоритмом, по которому переменные и методы по умолчанию имеют спецификатор private.
									Затем шаг за шагом увеличиваете доступ при необходимости (с private на protected, с protected на public).</p>
									<p style='font-size:1.1em'>Одним из вариантов инкапсуляции является Фабричный метод.
									Он инкапсулирует код создания объекта и обеспечивает гибкость для последующего создания новых объектов без влияния на существующий код.</p>

									<h3><br>Композиция вместо наследования</h3>

									<p style='font-size:1.1em'>Существует два основных способа повторного использования кода: наследование и композиция.
									Оба они имеют свои преимущества и недостатки, но, как правило, предпочтение рекомендуется отдавать последнему, если это возможно.
									Обусловлено это тем, что композиция гибче наследования.</p>
									<p style='font-size:1.1em'>Композиция позволяет изменять поведение класса прямо во время выполнения через установку его свойств.
									Реализуя интерфейсы, вы, таким образом, используете полиморфизм, который обеспечивает более гибкую реализацию.</p>

									<h3><br>Программирование для интерфейса</h3>

									<p style='font-size:1.1em'>Этот принцип подразумевает, что следует по возможности программировать для интерфейса, а не для его реализации.
									Это даст вам гибкий код, который может работать с любой новой реализацией интерфейса.</p>
									<p style='font-size:1.1em'>Другими словами, нужно использовать тип интерфейса для переменных, возвращаемых типов или типа аргумента метода.
									Например, использовать для хранения объекта суперкласс, а не подкласс.</p>

									<h3><br>Принцип делегирования</h3>

									<p style='font-size:1.1em'>Не делайте всё самостоятельно, делегируйте это в соответствующий класс.
									Если нужно сравнить два объекта, это действие поручается соответствующему классу вместо клиентского.</p>
									<p style='font-size:1.1em'>Основным преимуществом этого принципа является отсутствие дублирования кода и довольно простое изменение поведения.
									Этот принцип относится также к делегированию событий (событие делегируется соответствующему обработчику).</p>

									<h3><br>Заключение</h3>

									<p style='font-size:1.1em'>Эти принципы разработки помогают писать гибкий код, стремящийся к высокой связности и низкому зацеплению.
									Как только вы это освоите, следующим шагом будет изучение шаблонов проектирования для решения общих проблем разработки приложений и программного обеспечения.</p>

								</article>

						</div>
					</div>
				</div>

			<!-- Footer -->
				<div id="footer-wrapper">
					<footer id="footer" class="container">
						<div class="row">
							<div class="col-3 col-6-medium col-12-small">

								<!-- Links -->
									<section class="widget links">
										<h3>Разделы</h3>
										<ul class="style2">
											<li style='font-size:1.1em'><a href="index.html">Главная</a></li>
											<li style='font-size:1.1em'><a href="left-sidebar-1.1.html">Введение</a></li>
											<li style='font-size:1.1em'><a href="left-sidebar-2.1.html">ООП в C#</a></li>
											<li style='font-size:1.1em'><a href="no-sidebar.html">Парадигмы</a></li>
										</ul>
									</section>

							</div>
							<div class="col-6 col-6-medium col-12-small">

								<!-- Links -->
									<section class="widget links">
										<h3>Используемая литература</h3>
										<ul class="style2">
											<li style='font-size:1.1em'>habr.com/ru/post/87119</li>
											<li style='font-size:1.1em'>habr.com/ru/post/87205</li>
											<li style='font-size:1.1em'>tproger.ru/translations/10-oop-principles</li>
											<li style='font-size:1.1em'>youtube.com/playlist?list=PLL-k0Ff5RfqXGhAooRkUpzMLd6_Fpr13I</li>
										</ul>
									</section>

							</div>
							<div class="col-3 col-6-medium col-12-small">

								<!-- Contact -->
									<section class="widget contact last">
										<h3>Контакты</h3>
										<ul>
											<li><a href="https://vk.com/g_alex_creeper" target="_blank" class="icon brands fa-vk"><span class="label">Vkontakte</span></a></li>
											<li><a href="https://www.facebook.com/g.alex.creeper" target="_blank" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
											<li><a href="https://www.instagram.com/a_galukhin/" target="_blank" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
										</ul>
										<p>Россия, г.Иркутск<br/>
										Бульвар Гагарина, 68<br/>
										G.Alex.Creeper@yandex.ru</p>
									</section>

							</div>
						</div>
						<div class="row">
							<div class="col-12">
								<div id="copyright">
									<ul class="menu">
										<li>&copy; G_Alex. All rights reserved</li><li>Design: G_Alex studio</li>
									</ul>
								</div>
							</div>
						</div>
					</footer>
				</div>

			</div>

		<!-- Scripts -->

			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
